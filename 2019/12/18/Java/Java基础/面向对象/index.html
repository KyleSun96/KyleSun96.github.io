<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="面向对象"><meta name="keywords" content="Java,学习笔记"><meta name="author" content="Kyle Sun"><meta name="copyright" content="Kyle Sun"><meta name="theme-color" content="#0078E7"><title>面向对象 | 遇见凯尔</title><link rel="shortcut icon" href="/ico/Archer.ico"><link rel="mask-icon" href="/ico/Archer.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="dns-prefetch" href="https://cos.yunyoujun.cn"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    let Yun = window.Yun || {};
    let CONFIG = {"root":"/","title":"遇见凯尔","version":"0.6.3","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@700&amp;family=Source+Code+Pro&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_rtqh36oinzl.js" async></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc sidebar-nav-active hty-icon-button" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"/></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"/></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="Kyle Sun"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Kyle Sun"></a><div class="site-author-name"><a href="/about/">Kyle Sun</a></div><a class="site-name" href="/about/site.html">遇见凯尔</a><sub class="site-subtitle"></sub><div class="site-desciption">O ever youthful,O ever weeping</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"/></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"/></svg></span><span class="site-state-item-count">16</span></a></div><div class="site-state-item site-state-categories"><a href="/categories" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"/></svg></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item site-state-tags"><a href="/tags" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"/></svg></span><span class="site-state-item-count">12</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"/></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/KyleSun96" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"/></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:swy0907163@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"/></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=395966039" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"/></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/49793838" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"/></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="/images/wechat.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"/></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"/></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我的老婆们" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"/></svg></a></div></div><script defer src="/js/sidebar.js"></script><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修饰符"><span class="toc-number">1.1.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">1.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">1.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">1.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">1.5.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.6.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">1.7.</span> <span class="toc-text">内部类</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://kylesun96.github.io/2019/12/18/Java/Java基础/面向对象/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Kyle Sun"><meta itemprop="description" content="面向对象"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="遇见凯尔"></span><header class="post-header"><h1 class="post-title" itemprop="name headline" style="color: undefined">面向对象</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"/></svg></span> <time title="创建时间：2019-12-18 21:17:12" itemprop="dateCreated datePublished" datetime="2019-12-18T21:17:12+08:00">2019-12-18</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"/></svg></span> <time title="修改时间：2020-04-13 17:52:25" itemprop="dateModified" datetime="2020-04-13T17:52:25+08:00">2020-04-13</time></div><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"/></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="text">Java基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/Java/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"/></svg></span><span class="tag-name">Java</span></a><a class="tag" href="/tags/学习笔记/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"/></svg></span><span class="tag-name">学习笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><hr>
<ul>
<li><p>思想概述</p>
<ul>
<li><p>面向过程<br>  在完成一个功能的过程中,每一个步骤都自己来做,例如手洗衣服</p>
<ul>
<li><p>面向对象<br>在完成一个功能的过程中,不关心具体步骤,找一个具有该功能的人帮我做,例如让洗衣机洗衣服</p>
</li>
<li><p>三大特征<br>封装    继承    多态</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>类与对象</p>
<ul>
<li>类<br>现实生活中一类事物的抽象描述,包含属性和行为,例如有年龄和姓名的狗</li>
<li>对象<br>现实生活中一类事物的具体体现,是类的一个实例,例如3岁的叫旺财的狗</li>
</ul>
</li>
<li><p>类的定义</p>
<ul>
<li>属性<br>事物的状态信息,对应的是成员变量</li>
<li>行为<br>事物能够做什么,对应的是成员方法</li>
<li>注意事项<ol>
<li>成员变量定义的位置是类中方法外</li>
<li>成员方法定义的时候没有static</li>
</ol>
</li>
</ul>
</li>
<li><p>对象的使用</p>
<ol>
<li>导包<ul>
<li>格式<br>import 包名.类名</li>
<li>作用<br>说明使用的是哪一个类,要创建的是哪一个包下的哪一个类的对象</li>
<li>特殊情况<br>如果和当前类在同一个包,可以省略不写</li>
</ul>
</li>
<li>创建对象<br>   格式:    类名 对象名 = new 类名();</li>
<li>使用<ul>
<li>成员变量<ul>
<li>获取值<br>对象名.成员变量名</li>
<li>设置值<br>对象名.成员变量名 = 具体值</li>
<li>注意事项<br>如果没有对成员变量赋值,有默认值,规则和数组一样<ul>
<li>整数:    0</li>
<li>浮点数:    0.0</li>
<li>字符:    空字符</li>
<li>布尔:    false</li>
<li>引用类型:    null</li>
</ul>
</li>
</ul>
</li>
<li>成员方法<br>对象名.成员方法名();</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>成员变量和局部变量的区别</strong></p>
<ul>
<li>定义位置<ul>
<li>成员变量:    类中方法外</li>
<li>局部变量:    方法中</li>
</ul>
</li>
<li>作用范围<ul>
<li>成员变量:    整个类可以使用(所有成员方法)</li>
<li>局部变量:    当前方法,出了当前方法不能使用</li>
</ul>
</li>
<li>默认值<ul>
<li>成员变量:    有默认值,规则同数组</li>
<li>局部变量:    没有默认值,使用前必须手动赋值</li>
</ul>
</li>
<li>内存位置<ul>
<li>成员变量:    堆内存中</li>
<li>局部变量:    栈内存中</li>
</ul>
</li>
<li>生命周期<ul>
<li>成员变量:    随着对象的创建而诞生,随着对象被垃圾回收而消失</li>
<li>局部变量:    随着方法的进栈而诞生,随着方法出栈而消失</li>
</ul>
</li>
</ul>
</li>
<li><p>内存划分</p>
<ol>
<li>栈内存:    方法都是运行在栈内存</li>
<li>堆内存:    凡是new出来的都存放在堆内存中</li>
<li>方法区:    存放的是.class相关的信息</li>
</ol>
</li>
</ul>
<hr>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><hr>
<p>四种权限修饰符</p>
<ul>
<li><p>作用范围</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">default</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">同一个包</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包子类</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包非子类</td>
<td align="center">yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>  private:    当前类<br>  default:    当前包下的类<br>  protected:    所有子类<br>  public:    所有类</p>
</li>
</ul>
<ul>
<li>final<ul>
<li>概念<br>表示最终,不可改变的</li>
<li>修饰类<ul>
<li>格式:    public final class 类名{}</li>
<li>特点:    明该类是最终类,不能被继承</li>
</ul>
</li>
<li>修饰成员变量<ul>
<li>格式:    final 数据类型 变量名 = 具体值</li>
<li>特点:    表明该变量是常量,不能再次被赋值</li>
</ul>
</li>
<li>修饰方法<ul>
<li>格式<br>  public final 返回值类型 方法名(参数列表){<br>  方法体;<br>  }</li>
<li>特点:    表明该方法是最终方法,不能被重写</li>
</ul>
</li>
<li>修饰局部变量<ul>
<li>格式:    final 数据类型 变量名 = 具体值</li>
<li>特点:    修饰的局部变量只能赋值一次,不可改变</li>
<li>注意事项<ul>
<li>基本数据类型,不可改变的是变量中的具体值</li>
<li>引用类型,不可改变的是变量中的地址值,地址值指向的对象中的属性值可以改变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>static<ul>
<li>概念<br>表示静态的,被static修饰的内容属于类,被多个对象共享</li>
<li>修饰成员变量<pre><code>格式:    static 数据类型 变量名</code></pre></li>
<li>修饰成员方法<ul>
<li>格式:    public static 返回值类型 方法名(参数列表){}</li>
<li>调用<ul>
<li>对象名.方法名()        不推荐</li>
<li>类名.方法名()        推荐</li>
</ul>
</li>
<li><strong>注意事项</strong><br>  静态成员方法只能访问静态成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><hr>
<ul>
<li><p>概念<br>  将实现细节隐藏起来,对于外界不可见</p>
</li>
<li><p>private</p>
<ul>
<li>含义<br>权限修饰符,表示私有</li>
<li>作用<br>可以修饰成员变量和成员方法,被private修饰之后只能在本类中访问</li>
<li>使用<ul>
<li>格式<br>  private 数据类型 变量名</li>
<li>访问<br>  通过set和get方法</li>
</ul>
</li>
<li>注意事项<ol>
<li>方法名必须为setXxx和getXxx</li>
<li>set方法没有返回值,参数类型和成员变量一致</li>
<li>get方法没有参数,返回值类型和成员变量一致</li>
<li>布尔类型的成员变量,get方法名称为isXxx,set方法规则不变</li>
</ol>
</li>
</ul>
</li>
<li><p>this</p>
<ul>
<li>含义<br>表示当前对象,通过谁调用的方法,谁就是this</li>
<li>作用<br>当成员变量和局部变量重名时,用来指明要访问的是成员变量还是局部变量</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><p>概念<br>创建对象时执行的方法</p>
</li>
<li><p>格式<br>public 类名(参数类型 变量名,…){<br>  方法体;//赋值操作<br>}</p>
</li>
<li><p>作用:    用来对成员变量进行初始化(赋值)</p>
</li>
<li><p>注意事项</p>
<ol>
<li>构造方法名和类名相同</li>
<li>构造方法没有返回值,void也没有</li>
<li>如果一个构造方法都不写,编译器默认提供一个空参构造</li>
<li>如果写了一个构造方法,编译器将不再提供空参构造</li>
<li>构造方法可以进行重载</li>
</ol>
</li>
</ul>
</li>
<li><p>定义标准类</p>
<ul>
<li>组成<ol>
<li>私有的成员变量</li>
<li>成员变量对应的set和get方法</li>
<li>空参构造</li>
<li>带参构造</li>
</ol>
</li>
<li>初始化成员变量的两种方式<ul>
<li>带参构造<ul>
<li>好处:    一行代码可以同时赋值多个变量</li>
<li>缺点:    只能赋值一次,不能用来更改变量的值</li>
</ul>
</li>
<li>set和get方法<ul>
<li>好处:    可以随时调用,更改变量的值</li>
<li>缺点:    一次只能赋值一个变量,需要写很多行代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>概念<br>  子类继承父类的属性和行为,这样子类就有了和父类相同的属性和行为</li>
<li>好处<br>  提高了代码的复用性</li>
<li>格式<ul>
<li>父类<br>public class Father{<br>   public void method(){<br>   方法体;<br>   }<br>}</li>
<li>子类<br>public class Son extends Father{<br>//虽然没有写方法,可以从父类继承method方法,直接使用<br>}</li>
</ul>
</li>
<li>访问成员变量顺序<ul>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
</ul>
</li>
<li>变量重名<ul>
<li>局部变量与成员变量<ul>
<li>变量名<br>  就近原则,使用的是局部变量</li>
<li>this.变量名<br>  使用的是成员变量</li>
</ul>
</li>
<li>子类成员变量与父类成员变量<ul>
<li>this.变量名<br>  使用的是本类成员变量</li>
<li>super.变量名<br>  使用的是父类的成员变量</li>
</ul>
</li>
</ul>
</li>
<li>super<ul>
<li>访问父类的成员变量:    super.变量名</li>
<li>访问父类的成员方法:    super.方法名()</li>
<li>访问父类的构造方法:    super()</li>
</ul>
</li>
<li>访问构造方法<ul>
<li>初始化子类时,先初始化父类,不写默认调用super()</li>
<li>初始化子类时,可以调用父类的重载构造方法,空参带参都行,只能调用一个</li>
<li>初始化子类时,super必须写在第一行</li>
</ul>
</li>
<li>访问成员方法<ul>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
</ul>
</li>
<li>方法重写<ul>
<li>概念<br>继承关系中,子类的方法与父类的方法名称,参数列表相同</li>
<li>使用场景<ul>
<li>与父类方法的逻辑完全相同<br>  直接继承使用,不用重写</li>
<li>在父类方法的基础上增强<br>  先用super调用父类方法,之后写自己的逻辑代码</li>
<li>与父类方法的逻辑差别很大<br>  直接写自己的逻辑代码</li>
</ul>
</li>
<li>注意事项<ol>
<li>必须保证子类的方法与父类的方法名称,参数列表相同,可以通过@Override注解进行约束</li>
<li>必须保证子类的方法的访问权限大于或等于父类的方法的访问权限</li>
</ol>
</li>
</ul>
</li>
<li>继承的特点<ol>
<li>支持单继承,不支持多继承</li>
<li>支持多层继承</li>
</ol>
</li>
</ul>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>概念<br>  事物的多种形态</p>
</li>
<li><p>使用前提</p>
<ol>
<li>继承或实现关系</li>
<li>方法的重写</li>
<li>父类引用指向子类对象</li>
</ol>
</li>
<li><p>格式<br>  父类名称 对象名 = new 子类名称();<br>  接口名称 对象名 = new 实现类名称();</p>
</li>
<li><p>成员变量特点<br>  编译看左边,运行看左边</p>
</li>
<li><p>成员方法特点<br>  编译看左边,运行看右边</p>
</li>
<li><p>多态的好处和弊端</p>
<ul>
<li>好处:    提高了代码的拓展性</li>
<li>弊端:    不能运行子类特有方法</li>
</ul>
</li>
<li><p>向上转型</p>
<ul>
<li>格式:    父类类名 对象名 = new 子类类名()</li>
<li>含义:    创建了一个子类对象,把它当做父类类型进行使用</li>
</ul>
</li>
<li><p>向下转型</p>
<ul>
<li>格式:    子类名称 对象名 = (子类名称)父类类型对象名</li>
<li>含义:    将父类类型对象还原成为本来的子类类型对象进行使用</li>
<li>注意事项:    <ul>
<li>必须保证向下转型时是本来创建(new)时的类型,否则会发生异常(ClassCastException)</li>
<li>instanceof<ul>
<li>格式:    对象名 instanceof 类名</li>
<li>作用:    判断前边的对象是不是后边的类型,得到boolean结果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象方法<ul>
<li>概念<br>没有方法体的方法</li>
<li>格式<br>public abstract 返回值类型 方法名(参数列表);</li>
</ul>
</li>
<li>抽象类<ul>
<li>概念<br>包含抽象方法的类</li>
<li>格式<ul>
<li>public abstract class 类名{</li>
<li>public abstract 返回值类型 方法名(参数列表);<br>}</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ol>
<li>定义抽象类,抽象类不能直接创建对象使用</li>
<li>定义子类,继承抽象类</li>
<li>在子类中重写抽象类的所有抽象方法(去掉abstract,添加方法体大括号)</li>
<li>创建子类对象进行使用</li>
</ol>
</li>
<li>注意事项<ol>
<li>抽象类不能直接创建对象使用,可以创建子类对象使用,或者使用本类静态方法</li>
<li>抽象类可以有构造方法,是创建子类对象时,初始化父类成员使用的</li>
<li>包含抽象方法的类是抽象类,定义抽象类时可以不定义抽象方法,目的是不让别人创建对象使用</li>
<li>子类必须重写抽象父类中的所有抽象方法,否则报错,除非该子类也是抽象类</li>
</ol>
</li>
<li>使用场景<ol>
<li>父类知道自己有这个功能,但是不知道具体如何实现时,可以将这个方法定义成抽象方法</li>
<li>父类要求子类必须重写自己的某个方法时,可以将这个方法定义成抽象方法</li>
</ol>
</li>
</ul>
<hr>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>概念<br>  接口就是多个类的公共规范</p>
</li>
<li><p>格式</p>
<ul>
<li>定义接口<br>public interface 接口名{}</li>
<li>实现接口<br>pubic class 类名 implements 接口名{}</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li><p>常量</p>
<ul>
<li>格式<br>  public static final 数据类型 变量名 = 具体值;</li>
<li>使用<br>  接口名.变量名</li>
<li>注意事项<ol>
<li>接口中的成员变量都是常量 (默认由public static final修饰,可以省略不写)</li>
<li>接口中的常量必须进行赋值,赋值后不能改变</li>
<li>接口中常量命名推荐全大写,如果有多个单词,用下划线进行分割</li>
</ol>
</li>
</ul>
</li>
<li><p>抽象方法</p>
<ul>
<li><p>格式<br>  public abstract 返回值类型 方法名(参数列表);</p>
</li>
<li><p>使用步骤</p>
<ol>
<li>接口不能直接创建对象使用,需要实现类实现接口使用</li>
<li>实现类必须重写接口中的所有抽象方法</li>
<li>创建实现类对象进行使用</li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li>接口中抽象方法的修饰符必须是public abstract</li>
<li>public abstract 可以省略不写,写成 返回值类型 方法名(参数列表);</li>
<li>实现类必须重写接口中所有的抽象方法,否则报错,除非实现类是抽象类</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>类与接口的关系</p>
<ul>
<li>类与类:    单继承</li>
<li>类与接口:    多实现</li>
<li>接口与接口:    多继承</li>
</ul>
</li>
<li><p>使用场景</p>
<ol>
<li>用来定义规范</li>
<li>用来进行功能的拓展</li>
</ol>
</li>
<li><p>接口与抽象类的区别</p>
<ol>
<li>成员变量<br> 抽象类中可以是变量可以是常量,接口中都是常量</li>
<li>构造方法<br> 抽象类有构造方法,接口没有构造方法</li>
<li>成员方法<br> 抽象类可以有抽象方法和普通方法,接口中都是抽象方法</li>
</ol>
</li>
</ul>
<hr>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol>
<li><p>概念<br> 一个类的内部包含另一个类</p>
</li>
<li><p>成员内部类</p>
<ul>
<li>格式<br>  public class 类名{<pre><code>修饰符 class 内部类名称{
}</code></pre>  }</li>
<li><strong>注意事项</strong><ul>
<li>内部类使用外部类成员,直接使用</li>
<li>外部类使用内部类成员,创建内部类对象使用</li>
</ul>
</li>
<li>使用<br>1) 直接使用<br>  外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();<br>  <code>Outer.Inner oi = new Outer().new Inner();</code><br>  通过内部类对象使用内部类成员<br>2) 间接使用 在外部类成员方法中创建内部类对象使用,在测试类中创建外部类对象,调用成员方法进行使用    </li>
</ul>
</li>
<li><p>局部内部类</p>
<ul>
<li>格式<br>public class 类名{<br>  修饰符 返回值类型 方法名(参数列表){<pre><code>class 类名{
         //方法
}</code></pre>  }<br>}</li>
<li>使用:    只能在方法内部进行创建对象使用</li>
</ul>
</li>
<li><p><strong>匿名内部类</strong></p>
<ul>
<li><p>概念<br>当一个接口的实现类或一个父类的子类只用一次的时候,可以用匿名内部类实现</p>
</li>
<li><p>格式<br>  接口/父类名 对象名 = new 接口/父类名(){</p>
<pre><code>// 重写的方法</code></pre><p>  }</p>
</li>
<li><p>注意事项</p>
<ol>
<li>匿名内部类是定义类没有名字,匿名对象是创建对象没有名字</li>
<li>匿名内部类只能使用一次,在创建对象时只能使用一次(只能创建一次对象)</li>
<li>匿名对象只能使用一次,在调用方法时只能使用一次(只能调用一次方法)</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"/></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"/></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"/></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Kyle Sun</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://kylesun96.github.io/2019/12/18/Java/Java基础/面向对象/" title="面向对象">https://kylesun96.github.io/2019/12/18/Java/Java基础/面向对象/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"/></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"/></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"/></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"/></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2019/12/18/Java/Java基础/常用对象的API/" rel="prev" title="常用对象的API"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"/></svg><span class="post-nav-text">常用对象的API</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2019/12/17/Java/总结梳理/Java中继承关系的利弊/" rel="next" title="Java中继承关系的利弊"><span class="post-nav-text">Java中继承关系的利弊</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"/></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" href="https://github.com/KyleSun/kylesun96.github.io/issues?q=is:issue+面向对象">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"/></svg></span><span class="author"> Kyle Sun</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v3.9.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.6.3</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2019-09-27T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"/></svg><svg class="progress-circle-container" viewbox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"/></svg></a></div><script defer src="/js/hexo-theme-yun.js"></script></body></html>