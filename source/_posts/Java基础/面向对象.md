---
title: 面向对象
date: 2019-12-18 21:17:12
tags: 
 - Java
 - 学习笔记
categories:
 - Java基础
comments: true
keywords: 
description: 
---


## 面向对象

***

* 思想概述
  * 面向过程
	  在完成一个功能的过程中,每一个步骤都自己来做,例如手洗衣服
  
	* 面向对象
	  在完成一个功能的过程中,不关心具体步骤,找一个具有该功能的人帮我做,例如让洗衣机洗衣服
	
	* 三大特征
	  封装	继承	多态
* 类与对象
  * 类
	现实生活中一类事物的抽象描述,包含属性和行为,例如有年龄和姓名的狗
  * 对象
	现实生活中一类事物的具体体现,是类的一个实例,例如3岁的叫旺财的狗
* 类的定义
  * 属性
	事物的状态信息,对应的是成员变量
  * 行为
	事物能够做什么,对应的是成员方法
  * 注意事项
	  1. 成员变量定义的位置是类中方法外
	  2. 成员方法定义的时候没有static

* 对象的使用
  1. 导包
      * 格式
		import 包名.类名
      * 作用
		说明使用的是哪一个类,要创建的是哪一个包下的哪一个类的对象
      * 特殊情况
		如果和当前类在同一个包,可以省略不写
  2. 创建对象
	    格式:	类名 对象名 = new 类名();
  3. 使用
      * 成员变量
        * 获取值
		对象名.成员变量名
        * 设置值
		对象名.成员变量名 = 具体值
        * 注意事项
		如果没有对成员变量赋值,有默认值,规则和数组一样
          * 整数:	0
          * 浮点数:	0.0
          * 字符:	空字符
          * 布尔:	false
          * 引用类型:	null
      * 成员方法
		对象名.成员方法名();
	
* **成员变量和局部变量的区别**
  * 定义位置
    * 成员变量:	类中方法外
    * 局部变量:	方法中
  * 作用范围
    * 成员变量:	整个类可以使用(所有成员方法)
    * 局部变量:	当前方法,出了当前方法不能使用
  * 默认值
    * 成员变量:	有默认值,规则同数组
    * 局部变量:	没有默认值,使用前必须手动赋值
  * 内存位置
    * 成员变量:	堆内存中
    * 局部变量:	栈内存中
  * 生命周期
    * 成员变量:	随着对象的创建而诞生,随着对象被垃圾回收而消失
    * 局部变量:	随着方法的进栈而诞生,随着方法出栈而消失

* 内存划分
  1. 栈内存:	方法都是运行在栈内存
  2. 堆内存:	凡是new出来的都存放在堆内存中
  3. 方法区:	存放的是.class相关的信息

***

### 修饰符

***

四种权限修饰符

* 作用范围

	|    修饰符    | public | protected | default | private |
	| :----------: | :----: | :-------: | :-----: | :-----: |
	|   同一个类   |  yes   |    yes    |   yes   |   yes   |
	|   同一个包   |  yes   |    yes    |   yes   |         |
	|  不同包子类  |  yes   |    yes    |         |         |
	| 不同包非子类 |  yes   |           |         |         |

	private:	当前类
	default:	当前包下的类
	protected:	所有子类
	public:	所有类


* final
  * 概念
	表示最终,不可改变的
  * 修饰类
    * 格式:	public final class 类名{}
    * 特点:	明该类是最终类,不能被继承
  * 修饰成员变量
    * 格式:	final 数据类型 变量名 = 具体值
    * 特点:	表明该变量是常量,不能再次被赋值
  * 修饰方法
    * 格式
		public final 返回值类型 方法名(参数列表){
		方法体;
		}
    * 特点:	表明该方法是最终方法,不能被重写
  * 修饰局部变量
    * 格式:	final 数据类型 变量名 = 具体值
    * 特点:	修饰的局部变量只能赋值一次,不可改变
    * 注意事项
      * 基本数据类型,不可改变的是变量中的具体值
      * 引用类型,不可改变的是变量中的地址值,地址值指向的对象中的属性值可以改变
* static
  * 概念
	表示静态的,被static修饰的内容属于类,被多个对象共享
  * 修饰成员变量
		格式:	static 数据类型 变量名
  * 修饰成员方法
    * 格式:	public static 返回值类型 方法名(参数列表){}
    * 调用
      * 对象名.方法名()		不推荐
      * 类名.方法名()		推荐
    * **注意事项**
		静态成员方法只能访问静态成员
				
***

### 封装

***

* 概念
	将实现细节隐藏起来,对于外界不可见
* private
  * 含义
	权限修饰符,表示私有
  * 作用
	可以修饰成员变量和成员方法,被private修饰之后只能在本类中访问
  * 使用
    * 格式
		private 数据类型 变量名
    * 访问
		通过set和get方法
  * 注意事项
    1. 方法名必须为setXxx和getXxx
    2. set方法没有返回值,参数类型和成员变量一致
    3. get方法没有参数,返回值类型和成员变量一致
    4. 布尔类型的成员变量,get方法名称为isXxx,set方法规则不变
* this
  * 含义
	表示当前对象,通过谁调用的方法,谁就是this
  * 作用
	当成员变量和局部变量重名时,用来指明要访问的是成员变量还是局部变量
* 构造方法
  * 概念
	创建对象时执行的方法
  * 格式
	public 类名(参数类型 变量名,...){
	  方法体;//赋值操作
	}

  * 作用:	用来对成员变量进行初始化(赋值)
  * 注意事项
    1. 构造方法名和类名相同
    2. 构造方法没有返回值,void也没有
    3. 如果一个构造方法都不写,编译器默认提供一个空参构造
    4. 如果写了一个构造方法,编译器将不再提供空参构造
    5. 构造方法可以进行重载
* 定义标准类
  * 组成
    1. 私有的成员变量
    2. 成员变量对应的set和get方法
    3. 空参构造
    4. 带参构造
  * 初始化成员变量的两种方式
    * 带参构造
      * 好处:	一行代码可以同时赋值多个变量
      * 缺点:	只能赋值一次,不能用来更改变量的值
    * set和get方法
      * 好处:	可以随时调用,更改变量的值
      * 缺点:	一次只能赋值一个变量,需要写很多行代码

***

### 继承
* 概念
	子类继承父类的属性和行为,这样子类就有了和父类相同的属性和行为
* 好处
	提高了代码的复用性
* 格式
  * 父类
	public class Father{
       public void method(){
       方法体;
       }
	}
  * 子类
	public class Son extends Father{
	//虽然没有写方法,可以从父类继承method方法,直接使用
	}
* 访问成员变量顺序
  * 子类局部范围找
  * 子类成员范围找
  * 父类成员范围找
* 变量重名
  * 局部变量与成员变量
    * 变量名
		就近原则,使用的是局部变量
    * this.变量名
		使用的是成员变量
  * 子类成员变量与父类成员变量
    * this.变量名
		使用的是本类成员变量
    * super.变量名
		使用的是父类的成员变量
* super
  * 访问父类的成员变量:	super.变量名
  * 访问父类的成员方法:	super.方法名()
  * 访问父类的构造方法:	super()
* 访问构造方法
  * 初始化子类时,先初始化父类,不写默认调用super()
  * 初始化子类时,可以调用父类的重载构造方法,空参带参都行,只能调用一个
  * 初始化子类时,super必须写在第一行
* 访问成员方法
  * 子类成员范围找
  * 父类成员范围找
* 方法重写
  * 概念
	继承关系中,子类的方法与父类的方法名称,参数列表相同
  * 使用场景
    * 与父类方法的逻辑完全相同
		直接继承使用,不用重写
    * 在父类方法的基础上增强
		先用super调用父类方法,之后写自己的逻辑代码
    * 与父类方法的逻辑差别很大
		直接写自己的逻辑代码
  * 注意事项
    1. 必须保证子类的方法与父类的方法名称,参数列表相同,可以通过@Override注解进行约束
    2. 必须保证子类的方法的访问权限大于或等于父类的方法的访问权限
* 继承的特点
  1. 支持单继承,不支持多继承
  2. 支持多层继承

***

### 多态

* 概念
	事物的多种形态
	
* 使用前提
	1. 继承或实现关系
	2. 方法的重写
	3. 父类引用指向子类对象
	
* 格式
	父类名称 对象名 = new 子类名称();
	接口名称 对象名 = new 实现类名称();
	
* 成员变量特点
	编译看左边,运行看左边
	
* 成员方法特点
	编译看左边,运行看右边
	
* 多态的好处和弊端
  * 好处:	提高了代码的拓展性
  * 弊端:	不能运行子类特有方法
	
* 向上转型
  * 格式:	父类类名 对象名 = new 子类类名()
  * 含义:	创建了一个子类对象,把它当做父类类型进行使用
	
* 向下转型
  * 格式:	子类名称 对象名 = (子类名称)父类类型对象名
  * 含义:	将父类类型对象还原成为本来的子类类型对象进行使用
  * 注意事项:	
	  * 必须保证向下转型时是本来创建(new)时的类型,否则会发生异常(ClassCastException)
	  * instanceof
	    * 格式:	对象名 instanceof 类名
	    * 作用:	判断前边的对象是不是后边的类型,得到boolean结果

***

### 抽象类

* 抽象方法
  * 概念
	没有方法体的方法
  * 格式
	public abstract 返回值类型 方法名(参数列表);
* 抽象类
  * 概念
	包含抽象方法的类
  * 格式
    * public abstract class 类名{
    * public abstract 返回值类型 方法名(参数列表);
	  }
* 使用步骤
  1. 定义抽象类,抽象类不能直接创建对象使用
  2. 定义子类,继承抽象类
  3. 在子类中重写抽象类的所有抽象方法(去掉abstract,添加方法体大括号)
  4. 创建子类对象进行使用
* 注意事项
  1. 抽象类不能直接创建对象使用,可以创建子类对象使用,或者使用本类静态方法
  2. 抽象类可以有构造方法,是创建子类对象时,初始化父类成员使用的
  3. 包含抽象方法的类是抽象类,定义抽象类时可以不定义抽象方法,目的是不让别人创建对象使用
  4. 子类必须重写抽象父类中的所有抽象方法,否则报错,除非该子类也是抽象类
* 使用场景
  1. 父类知道自己有这个功能,但是不知道具体如何实现时,可以将这个方法定义成抽象方法
  2. 父类要求子类必须重写自己的某个方法时,可以将这个方法定义成抽象方法

***

### 接口

* 概念
	接口就是多个类的公共规范
* 格式
  * 定义接口
	public interface 接口名{}
  * 实现接口
	pubic class 类名 implements 接口名{}
* 组成
  * 常量
    * 格式
		public static final 数据类型 变量名 = 具体值;
    * 使用
		接口名.变量名
    * 注意事项
      1. 接口中的成员变量都是常量 (默认由public static final修饰,可以省略不写)
      2. 接口中的常量必须进行赋值,赋值后不能改变
      3. 接口中常量命名推荐全大写,如果有多个单词,用下划线进行分割
  * 抽象方法
    * 格式
		public abstract 返回值类型 方法名(参数列表);
    * 使用步骤
      1. 接口不能直接创建对象使用,需要实现类实现接口使用
      2. 实现类必须重写接口中的所有抽象方法
      3. 创建实现类对象进行使用

    * 注意事项
      1. 接口中抽象方法的修饰符必须是public abstract
      2. public abstract 可以省略不写,写成 返回值类型 方法名(参数列表);
      3. 实现类必须重写接口中所有的抽象方法,否则报错,除非实现类是抽象类

* 类与接口的关系
  * 类与类:	单继承
  * 类与接口:	多实现
  * 接口与接口:	多继承

* 使用场景
	1. 用来定义规范
	2. 用来进行功能的拓展
* 接口与抽象类的区别
    1. 成员变量
		抽象类中可以是变量可以是常量,接口中都是常量
    2. 构造方法
		抽象类有构造方法,接口没有构造方法
    3. 成员方法
		抽象类可以有抽象方法和普通方法,接口中都是抽象方法
	
***

### 内部类
1. 概念
	一个类的内部包含另一个类
2. 成员内部类
    * 格式
		public class 类名{
		  修饰符 class 内部类名称{
    	  }
		}
    * **注意事项**
	  * 内部类使用外部类成员,直接使用
	  * 外部类使用内部类成员,创建内部类对象使用
    * 使用
	  1) 直接使用
	    外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
	    `Outer.Inner oi = new Outer().new Inner();`
	    通过内部类对象使用内部类成员
	  2) 间接使用 在外部类成员方法中创建内部类对象使用,在测试类中创建外部类对象,调用成员方法进行使用	

3. 局部内部类
    * 格式
	public class 类名{
        修饰符 返回值类型 方法名(参数列表){
           class 类名{
                    //方法
           }
        }
	}
    * 使用:	只能在方法内部进行创建对象使用

4. **匿名内部类**
   
    * 概念
      当一个接口的实现类或一个父类的子类只用一次的时候,可以用匿名内部类实现

    * 格式
        接口/父类名 对象名 = new 接口/父类名(){
           // 重写的方法
        }
    
    * 注意事项
      1. 匿名内部类是定义类没有名字,匿名对象是创建对象没有名字
      2. 匿名内部类只能使用一次,在创建对象时只能使用一次(只能创建一次对象)
      3. 匿名对象只能使用一次,在调用方法时只能使用一次(只能调用一次方法)

***

